## Représentation I

- Image en noir et blanc: matrice de dimension $L \times W$
- Plusieurs encodages possibles: valeurs entières entre 0 et 255 (`uint8`), valeurs flottantes entre 0 et 1, etc.

![](img/python_pixels.png){fig-align="center" height=400}

## Représentation II

- Image en couleurs: matrice de dimension $L \times W \times 3$

::: {#fig-image-couleur layout="[[-26,14,-26], [-8,16,-1,16,-1,16,-8]]"}
![](img/rgb_image.png)

![](img/python_red.png)

![](img/python_green.png)

![](img/python_blue.png)
:::

## Vision par ordinateur I

- Techniques qui permettent à des machines d'acquérir une compréhension d'images ou de vidéos numériques
- 1973: détection de contours

::: {#fig-sobel layout="[-3,10,-1,10,-3]"}
![](img/bike.jpg)

![](img/bike_sobel.jpg)
:::

## Vision par ordinateur II

- On définit les images suivantes: 

$$
G_x = \begin{bmatrix}
+1 & 0 & -1\\
+2 & 0 & -2\\
+1 & 0 & -1
\end{bmatrix} \star A \quad \text{et} \quad G_y = \begin{bmatrix}
+1 & +2 & +1\\
0 & 0 & 0\\
-1 & -2 & -1
\end{bmatrix} \star A
$$

avec $\star$ l'opérateur de convolution 2-dimensionnel en traitement du signal
- Alors $G = \sqrt{G_x^2 + G_y^2}$: représentation des contours de l'image $A$

## Opérateur de convolution

::: {#fig-convol}
![](img/convol.png){ width=60% }

Illustration de l'opérateur de convolution 2-dimensionnel $\star$. Le noyau (matrice en bleu sur le dessin) est multiplié par -1 et *glisse* sur la matrice de gauche. Une multiplication élément par élément est faite sur chaque sous-matrice de la taille du noyau. Pour chacune de ces multiplication, les coefficients sont ensuite sommés pour donner une valeur de sortie unique. Par exemple ici, la valeur du pixel en vert correspond au calcul $3 = 1*(-1) + 1*1 + 1*2 + 1*1$.
:::